use futures::{
    future::{self, Ready},
    prelude::*,
};
use std::io;
use std::sync::Arc;
use std::thread;
use tarpc::{
    context,
    server::{self, Channel, Handler},
};
use tarpc_bincode_transport as bincode_transport;

use crate::generic::GraphTrait;
use crate::generic::{DefaultId, Void};
use crate::graph_impl::UnStaticGraph;

type DefaultGraph = UnStaticGraph<Void>;

#[tarpc::service]
pub trait GraphRPC {
    async fn neighbors(id: DefaultId) -> Vec<DefaultId>;
//    async fn degree(id: DefaultId) -> usize;
}

#[derive(Clone)]
pub struct GraphServer {
    graph: Arc<DefaultGraph>,
}

impl GraphServer {
    pub fn new(graph: Arc<DefaultGraph>) -> Self {
        GraphServer { graph }
    }

    pub async fn run(self, port: u16, max_channel: usize, max_channels_per_key:usize) -> io::Result<()> {
        let server_addr = ([0, 0, 0, 0], port).into();

        let transport = bincode_transport::listen(&server_addr)?;
        //            .unwrap_or_else(|e| panic!("RPC server cannot be started: {:?}", e));

        info!("Running RPC server on {:?}", transport.local_addr());

        transport
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(max_channels_per_key as u32, |t| t.as_ref().peer_addr().unwrap().ip())
            .max_concurrent_requests_per_channel(max_channels_per_key)
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated RPC trait.
            .map(|channel| {
                let server = self.clone();

                channel.respond_with(server.serve()).execute()
            })
            .buffer_unordered(max_channel)
            .for_each(|_| async {})
            .await;

        Ok(())
    }

    pub fn run_thread(self, port: u16, max_channel: usize,max_channels_per_key:usize) {
        let _ = thread::spawn(move || {
            let runtime = tokio::runtime::Runtime::new()
                .unwrap_or_else(|e| panic!("Unable to start the runtime: {:?}", e));
            let run = self.run(port, max_channel, max_channels_per_key);
            runtime.block_on(async move {
                if let Err(e) = run.await {
                    panic!("Error while running server: {}", e);
                }
            });
        });
    }
}

impl GraphRPC for GraphServer {
    type NeighborsFut = Ready<Vec<DefaultId>>;

    fn neighbors(self, _: context::Context, id: DefaultId) -> Self::NeighborsFut {
        let vec = self.graph.neighbors(id).into();

        future::ready(vec)
    }

//    type DegreeFut = Ready<usize>;
//
//    fn degree(self, _: context::Context, id: DefaultId) -> Self::DegreeFut {
//        let degree = self.graph.degree(id);
//
//        future::ready(degree)
//    }
}
