use std::net::SocketAddr;
use std::sync::Arc;

use futures::{
    future::{self, Ready},
    prelude::*,
};
use tarpc::{
    context,
    server::{self, Channel, Handler},
};
use tarpc_bincode_transport as bincode_transport;

use crate::generic::GraphTrait;
use crate::generic::{DefaultId, Void};
use crate::graph_impl::UnStaticGraph;

type DefaultGraph = UnStaticGraph<Void>;

#[tarpc::service]
pub trait GraphRPC {
    async fn neighbors(id: DefaultId) -> Vec<DefaultId>;
}

#[derive(Clone)]
pub struct GraphRPCServer {
    socket_addr: Option<SocketAddr>,
    graph: Arc<DefaultGraph>,
}

impl GraphRPCServer {
    pub fn new(graph: Arc<DefaultGraph>) -> Self {
        GraphRPCServer {
            socket_addr: None,
            graph,
        }
    }

    pub fn set_socket_addr(&mut self, addr: SocketAddr) {
        self.socket_addr = Some(addr);
    }

    pub async fn run(&self, port: u16, max_channel: usize) {
        let server_addr = ([0, 0, 0, 0], port).into();

        bincode_transport::listen(&server_addr)
            .unwrap_or_else(|e| panic!("RPC server cannot be started: {:?}", e))
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated RPC trait.
            .map(|channel| {
                let socket_addr = channel.as_ref().as_ref().peer_addr().unwrap();
                let mut server = self.clone();
                server.set_socket_addr(socket_addr);
                info!("Running RPC server on {:?}", socket_addr);

                channel.respond_with(server.serve()).execute()
            })
            .buffer_unordered(max_channel)
            .for_each(|_| async {})
            .await;
    }
}

impl GraphRPC for GraphRPCServer {
    type NeighborsFut = Ready<Vec<DefaultId>>;

    fn neighbors(self, _: context::Context, id: DefaultId) -> Self::NeighborsFut {
        let vec = self.graph.neighbors(id).into();

        future::ready(vec)
    }
}
